$Id$

RLB v0.5  Jason Armstrong <ja@riverdrums.com>
Copyright (c) 2006-2007 Riverdrums
http://rlb.sourceforge.net

LICENSE

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.


PREFACE

RLB is a TCP load balancer aimed at clarity and efficiency.


REQUIREMENTS

This program requires the libevent library by Niels Provos, available from:
  http://www.monkey.org/~provos/libevent/


COMPILING

1. Install libevent

2. Compile RLB:

  $ gcc -Wall -O2 -o rlb rlb.c -levent

  Solaris:
  $ cc -Wall -O2 -o rlb rlb.c -lnsl -lsocket -levent

  If you want to use the content filtering (shared object) API:
  $ gcc -DRLB_SO -Wall -O2 -o rlb rlb.c -levent (-ldl)

3. Optionally, compile a shared object filter:

  To compile your own filter from a filter.c source file:
  $ gcc -DRLB_SO -Wall -O2 -I. -fPIC -shared -o filter.so filter.c

  To use your own filter:
  $ rlb -p 80 -h host1 -h host2 [other options] -o ./filter.so

Build options for other architectures: please send to the author.


USAGE

$ rlb -p port -h host[:service:max] [-h host[:service:max] ...] [-b addr] [-B addr] [-m max] [-t timeout] [-c check interval] [-s bufsize] [-n servers] [-u user] [-j jail] [-l clients] [-r] [-S] [-d] [-f] [-o shared object] [-o shared object ...]


OPTIONS

  -p  port  Listen on this port
  -h  host[:service:max]
            Specify a backend server and service. The 'max' parameter, if
            specified, is the maximum number of simultaneous connections
            allowed to that server.
            Service can be a port number (80) or service name (www). If
            the service is not given, then it defaults to the -p
            parameter (local port listened on). In this case, the port
            parameter must precede the host parameter.
            This option can be specified multiple times.
  -b  addr  Bind to this interface when listening.
  -B  addr  Bind to this interface when connecting to backend servers.
  -m  max   Maximum number of accepted connections to the load balancer. The
            default is to use the system limit (RLIMIT_NOFILE). The minimum
            value for this field is enforced to 8. This is a file
            descriptor limit, and each connection uses two descriptors,
            one for the client and one to the backend server.
  -t  secs  Timeout value in seconds for read/write operations on sockets. The
            default value is 30 seconds.
  -c  secs  Time in seconds after which a server that is not active is checked.
            The default value is 30 seconds. 
  -s  size  Buffer size. The program allocates this at startup.  The
            default value is taken from the socket option SO_SNDBUF,
            which may be too large (it is 16384 on my machine).
  -n  num   Number of processes to start. All processes will listen on the same
            port. Set to the number of CPUs.
  -l  num   Number of clients to keep track of simultaneously. Oldest clients
            are kicked out. This implements simple sessions, where the
            same IP address will be sent back to the same server.
            Default is 4096. For more advanced session tracking, write a
            content filter.
  -S        Stubborn client. If the client connected to a certain server
            previously and it is currently unavailable (or maxed out), then
            don't try any other servers.
  -r        Round robin. Don't retain client IP/server pairs.
  -j  jail  Chroot to this directory on startup.
  -u  user  Run as this user.
  -d        Delayed connect. Only connect after the first read. This is for
            use with content filters, which may want to select a server
            to connect to based on the very first data that is read.
  -f        Run in the foreground (cancels the -n option)
  -o  so    Load the specified shared object content filter. This option
            can be specified multiple times. Filters are called in the
            order in which they are given on the command line.


CLIENT TRACKING

Client/server pairs are stored up to a configurable value (default is
4096), after which the oldest is expired to make way for the new one.
To disable this behaviour, and implement simple round-robin choice of
servers, specify the -r command line option.

If a client previously connected to a certain server, and that server is
unavailable when the client connects again, then the default behaviour
is to try the next available server in the cluster. This can be
overriden with the -S flag, which tells the load balancer to be stubborn
about previous client/server pairs. In this case, if the server is
unavailable, the client will be disconnected (and won't be able to
transact until it is expired from the client tracking array, or the
server becomes available again).

For more advanced session tracking, such as cookie tracking for HTTP
requests, see the content filtering API.


CONTENT FILTER API

RLB provides an API via a shared object to user-defined content filters.
For this to work, rlb must be compiled with RLB_SO defined (add -DRLB_SO
to the make options).

Filters can be chained together and will be called in the order in which
they are given on the command line.

Five API functions are defined. None are required, and they are only
called if they are found in the shared object.

An example http filter program is included. It rewrites 'Host' and
'Referer' fields from the client to the backend server (probably not
necessary), as well as rewriting 'Location' headers from the server to
the client (quite useful). It also logs all requests so that a unified
logfile can be accessed which will have the correct details of the
client IP address (to backend servers, all requests come from the load
balancer's IP address). You will need to modify a few variables at the
top of the file to get it to work for your setup.

1. int rlb_init(struct cfg *, void **);

  This function is called on startup. It takes the configuration
  structure and a pointer reference as parameters. It is called after
  everything has been configured and setup, just before the call to
  listen(). If you return less than 0 from this function, the program
  will exit.

  If you want to set your own 'global' parameters, a variable pointer
  'data' is provided. You can store anything in it, it is defined as
  'void *'. For example, you could malloc() your own data structure and
  point '*data' to it. You should then provide rlb_cleanup() with a
  method of freeing any resources you allocate. You can access this data
  structure for the duration of the process in any of the other API
  calls. It is persistent whilst rlb is running. Each filter can set
  their own data container separately.

  Example:

int rlb_init(struct cfg *cfg, void **data) {
  FILE *f = fopen("rlb_filter.log", "a+");
  if (f) *data = (void *) f;
  return 0;
}


2. void rlb_cleanup(struct cfg *, void **);

  This function is called just before the process exits, before the
  handle to the shared object is closed. You should generally use it to
  de-allocate resources, and perform any other closing down actions
  necessary.

  Example:

void rlb_cleanup(struct cfg *cfg, void **) {
  FILE *f = (FILE *) *data;
  if (f) fclose(f);
}


3. int rlb_filter(struct connection *, int, void *);

  This is the most useful function. It is called after every data read,
  in both directions. It is passed the connection data structure, where
  the data buffer, positions and length can be accessed, as well as an
  integer which represents the amount of data read in the last call to
  read(). The third parameter is a per-filter data container that must
  have been previously assigned in rlb_init().

  You can pretty much do what you like with the data, including
  reallocating memory if you want to rewrite data in the data buffer.
  But note that you have to be *very careful* about what you do here,
  including re-calculating lengths and data positions, if you decide to
  tamper with the data. If you find that rlb is giving segmentation
  faults, the problem is probably here. Also note that the data buffer
  can't be dealt with simply as a string, although when rlb starts it
  allocates one more byte than the official length. You can therefore do
  something like this:

int rlb_filter(struct connection *c, int r) {
  *(c->b + c->pos + c->len) = 0;
}

  And you are guaranteed that you won't be overrunning the end of the
  buffer. If you reallocate the buffer yourself, though, and don't
  allocate the extra byte, then all bets are off.

  Some things to note:

  a) All variables are incremented before this function is called (ie
     totals, buffer lengths etc).
  b) The second parameter is only the number of bytes in the last call
     to read(). 
  c) To see if this is the very first read on a connection:
     if (c->nr - r == 0) { /* First read */ }
  d) You can distinguish between client and server connections by
     examining the c->scope parameter:
     if (c->scope == RLB_CLIENT) { /* Client specific */ }
     if (c->scope == RLB_SERVER) { /* Server specific */ }
  e) You have access to the global configuration structure via the
     c->cfg variable.
  f) The client and server are 'paired'. To get the other side of the
     pair, you need to check the c->od variable, and then find the
     corresponding connection structure:
     if (c->od >= 0) {
       struct cfg *cfg = c->cfg;
       struct connection *other = &cfg->conn[c->od];
     }
     It may not always be defined (eg if -d is specified, the first call
     to the filter will not have have a corresponding server
     connection).
  g) The buffer size is stored in the variable c->bs. If you reallocate
     the data buffer (c->b), you need to reassign this variable too.
  h) Total statistics for a connection are in the variables c->nr
     (number of bytes read) and c->nw (bytes written).
  i) The data that has just been read might not start at the beginning
     of the data buffer. If you want to examine the latest read data,
     you should always use c->b + c->pos. The data length will be c->len
     bytes.
  j) There is also a 'void *' userdata parameter in the connection
     structure, that is persistent across a connection. It can be used
     as a data container, and should be freed in the corresponding call
     to rlb_close(). This is different than the variable passed to the
     rlb_filter() function, 'data', which is the 'global' data pointer
     (ie the one assigned by rlb_init()). If you assigned c->userdata,
     you should free the applicable resources in rlb_close().

4. void rlb_close(struct connection *, void *);

  Called for each connection when it is closed. It is called before any
  of the other closing operations, such as shutting down the socket,
  happen, so you still have access to all the variables, such as total
  bytes read, written, information regarding the server that was
  connected to, client connection data etc. The second parameter, a void
  pointer, is the pointer to the 'global' data that gets assigned in
  rlb_init(). Access to connection specific data is in the userdata
  variable in the connection structure.

5. void rlb_get_server(struct cfg *, struct connection *);

  This function is meant as a user defined replacement for selecting
  which server to direct a connection to. It is not complete as yet, and
  shouldn't be relied on to stay in it's current format.

  Basically, you allocate the so_server (server *) variable in the
  connection data structure. The rlb engine then notices this, and
  connects to your specified server. You need to assign the variables in
  the server structure, such as the addrinfo pointer, as well as the
  'status' variable to indicate that the server is alive. See the
  example rlb_http_filter.c file.

  You can also set the c->reconnect variable to 1. This will tell rlb to
  renogotiate a server.


MEMORY USAGE

The default behaviour is to take the maximum number of file descriptors
that can be opened by the process, and for each of these 'connection'
data structures, to allocate a SO_SNDBUF size char array.  This will
result in the program allocating > 16 Mb of memory. If this is an issue,
then you need to either reduce the maximum number of connections (via
the -m max flag) or the size of the allocated buffers (via the -s size
flag), or both.


SERVER WEIGHTING

Currently, all servers in the cluster have equal weighting and will be
selected in turn.

To give a server extra weight, it can be specified more than once on the
command line. For example, using: '-h s1 -h s1 -h s2' will
cause server s1 to receive two thirds of requests and server s2 will
receive one third.

Another way to control throughput to servers is to limit the maximum
number of simultaneous connections that they can accept via the third
parameter to the -h argument.

A third way is via the rlb_get_server() API, where you can write your
own server weighting algorithm.


SIGNALS

Sending a SIGUSR1 signal to rlb will cause it to write out a status file
with the following information:

  - Sockets in use
  - Server status (number connected, last failed operation)
  - Client tracking status

The file will be called 'rlb.status.PID' in the rlb running directory.

Sending a SIGUSR2 signal will tell rlb to examine each server again. By
default it will only do this every 30 seconds (or after the parameter
set by -c).


CODING STYLE

This project has also been an exercise in style. The rlb.c file has the
intention of being as compressed, concise and explosive as possible. It
is not commented, and is dense and spiky.

The example filter file (rlb_http_filter.c) is the opposite, expansive,
well-commented and relaxed. It invites you to enjoy it at your leisure.


TODO

1. Server selection algorithms
2. Reload on the fly without losing any current connections
3. Re-select server after first read error (non-blocking connect error)
4. Finalise the rlb_get_server() API interface
5. Server weighting


CREDITS

Niels Provos for the great libevent library. 

I have looked at and learned from a few other load balancers and related
programs, including:

 - PLB by Frank Denis         http://plb.sunsite.dk
 - Pen by Ulric Eriksson      http://siag.nu/pen/
 - Balance by Thomas Obermair http://balance.sourceforge.net
 - Pound by Robert Segall     http://www.apsis.ch/pound
 - Netcat                     http://netcat.sourceforge.net
 - proxy_load_balancer        http://httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html

Thanks.


FEEDBACK

Feedback is welcome and appreciated. Please contact the author.


AUTHOR

Jason Armstrong <ja@riverdrums.com>


LINKS

http://rlb.sourceforge.net


# vim:tw=72:ts=2:si:ai:cin:fo=croqtln:is:ft=readme
